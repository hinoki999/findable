[1mdiff --git a/mobile/src/screens/HomeScreen.tsx b/mobile/src/screens/HomeScreen.tsx[m
[1mindex 6ef8e38..0cc1a41 100644[m
[1m--- a/mobile/src/screens/HomeScreen.tsx[m
[1m+++ b/mobile/src/screens/HomeScreen.tsx[m
[36m@@ -1,5 +1,6 @@[m
 Ôªøimport React, { useState, useEffect, useRef, useMemo } from 'react';[m
 import { View, Text, Animated, Pressable, Modal, ScrollView, PanResponder, RefreshControl, Dimensions, Platform } from 'react-native';[m
[32m+[m[32mimport { GestureDetector, Gesture } from 'react-native-gesture-handler';[m
 import { useSafeAreaInsets } from 'react-native-safe-area-context';[m
 import { MaterialCommunityIcons } from '@expo/vector-icons';[m
 import { getTheme } from '../theme';[m
[36m@@ -578,14 +579,6 @@[m [mexport default function HomeScreen() {[m
   const rotationAnimValue = useRef(new Animated.Value(0)).current;[m
   const scaleAnimValue = useRef(new Animated.Value(1)).current;[m
   [m
[31m-  // Gesture tracking for pinch and rotation[m
[31m-  const gestureState = useRef({[m
[31m-    initialScale: 1,[m
[31m-    initialAngle: 0,[m
[31m-    initialDistance: 0,[m
[31m-    startAngle: 0,[m
[31m-  }).current;[m
[31m-  const touchPositions = useRef<{ [key: string]: { x: number; y: number } }>({});[m
   const { isDarkMode } = useDarkMode();[m
   const { pinnedIds, togglePin } = usePinnedProfiles();[m
   const { profile } = useUserProfile();[m
[36m@@ -994,64 +987,44 @@[m [mexport default function HomeScreen() {[m
 [m
   // ========== RAW TOUCH HANDLERS (PINCH ZOOM & ROTATION) ==========[m
   [m
[31m-  const handleTouchStart = (event: any) => {[m
[31m-    const touches = event.nativeEvent.touches;[m
[31m-    touches.forEach((touch: any) => {[m
[31m-      touchPositions.current[touch.identifier] = { x: touch.pageX, y: touch.pageY };[m
[32m+[m[32m  // Gesture handlers for pinch-twist (zoom + rotation) - NO PANNING[m
[32m+[m[32m  const baseScale = useRef(1);[m
[32m+[m[32m  const baseRotation = useRef(0);[m
[32m+[m
[32m+[m[32m  // Pinch gesture for ZOOM only[m
[32m+[m[32m  const pinchGesture = Gesture.Pinch()[m
[32m+[m[32m    .onBegin(() => {[m
[32m+[m[32m      baseScale.current = viewScale;[m
[32m+[m[32m      console.log('üîç Pinch zoom started');[m
[32m+[m[32m    })[m
[32m+[m[32m    .onUpdate((event) => {[m
[32m+[m[32m      // ZOOM - constrained between 0.8x and 4x, centered on nucleus[m
[32m+[m[32m      const newScale = Math.max(0.8, Math.min(4, baseScale.current * event.scale));[m
[32m+[m[32m      setViewScale(newScale);[m
[32m+[m[32m      scaleAnimValue.setValue(newScale);[m
[32m+[m[32m    })[m
[32m+[m[32m    .onEnd(() => {[m
[32m+[m[32m      console.log('üîç Pinch zoom ended - Final scale:', viewScale);[m
     });[m
[31m-    [m
[31m-    if (touches.length === 2) {[m
[31m-      const [touch1, touch2] = touches;[m
[31m-      const distance = Math.sqrt([m
[31m-        Math.pow(touch2.pageX - touch1.pageX, 2) + [m
[31m-        Math.pow(touch2.pageY - touch1.pageY, 2)[m
[31m-      );[m
[31m-      gestureState.initialScale = viewScale;[m
[31m-      gestureState.initialDistance = distance;[m
[31m-      [m
[31m-      const angle = Math.atan2(touch2.pageY - touch1.pageY, touch2.pageX - touch1.pageX);[m
[31m-      gestureState.initialAngle = viewRotation;[m
[31m-      gestureState.startAngle = angle;[m
[31m-      [m
[31m-      console.log('üîç TWO FINGER TOUCH START - Distance:', distance, 'Angle:', angle);[m
[31m-    }[m
[31m-  };[m
 [m
[31m-  const handleTouchMove = (event: any) => {[m
[31m-    const touches = event.nativeEvent.touches;[m
[31m-    [m
[31m-    if (touches.length === 2) {[m
[31m-      const [touch1, touch2] = touches;[m
[31m-      [m
[31m-      // PINCH (zoom)[m
[31m-      const distance = Math.sqrt([m
[31m-        Math.pow(touch2.pageX - touch1.pageX, 2) + [m
[31m-        Math.pow(touch2.pageY - touch1.pageY, 2)[m
[31m-      );[m
[31m-      if (gestureState.initialDistance) {[m
[31m-        const scale = (distance / gestureState.initialDistance) * gestureState.initialScale;[m
[31m-        // Constrain zoom: min 0.8x (80%), max 4x (400%)[m
[31m-        const constrainedScale = Math.max(0.8, Math.min(4, scale));[m
[31m-        setViewScale(constrainedScale);[m
[31m-        scaleAnimValue.setValue(constrainedScale);[m
[31m-        console.log('üîç PINCH DETECTED - Scale:', constrainedScale);[m
[31m-      }[m
[31m-      [m
[31m-      // ROTATION[m
[31m-      const angle = Math.atan2(touch2.pageY - touch1.pageY, touch2.pageX - touch1.pageX);[m
[31m-      if (gestureState.startAngle !== undefined) {[m
[31m-        const rotation = gestureState.initialAngle + (angle - gestureState.startAngle);[m
[31m-        setViewRotation(rotation);[m
[31m-        rotationAnimValue.setValue(rotation);[m
[31m-        console.log('üîç ROTATION DETECTED - Angle:', rotation);[m
[31m-      }[m
[31m-    }[m
[31m-  };[m
[32m+[m[32m  // Rotation gesture for TWIST[m
[32m+[m[32m  const rotationGesture = Gesture.Rotation()[m
[32m+[m[32m    .onBegin(() => {[m
[32m+[m[32m      baseRotation.current = viewRotation;[m
[32m+[m[32m      console.log('üîç Rotation started');[m
[32m+[m[32m    })[m
[32m+[m[32m    .onUpdate((event) => {[m
[32m+[m[32m      // ROTATION - twist without translation/panning, centered on nucleus[m
[32m+[m[32m      const newRotation = baseRotation.current + event.rotation;[m
[32m+[m[32m      setViewRotation(newRotation);[m
[32m+[m[32m      rotationAnimValue.setValue(newRotation);[m
[32m+[m[32m    })[m
[32m+[m[32m    .onEnd(() => {[m
[32m+[m[32m      console.log('üîç Rotation ended - Final rotation:', viewRotation);[m
[32m+[m[32m    });[m
 [m
[31m-  const handleTouchEnd = () => {[m
[31m-    touchPositions.current = {};[m
[31m-    console.log('üîç TOUCH END - Reset');[m
[31m-  };[m
[32m+[m[32m  // Compose both gestures to work simultaneously[m
[32m+[m[32m  const composedGesture = Gesture.Simultaneous(pinchGesture, rotationGesture);[m
 [m
   // Stack drag animation[m
   const dragOffset = useRef(new Animated.Value(0)).current;[m
[36m@@ -1364,12 +1337,8 @@[m [mexport default function HomeScreen() {[m
   return ([m
     <Animated.View style={{ flex:1, backgroundColor: theme.colors.bg, opacity: fadeAnim }}>[m
       {/* Curved Grid Background - 2D grid with slight curve for 3D effect */}[m
[31m-      <View [m
[31m-        style={{ flex: 1 }}[m
[31m-        onTouchStart={handleTouchStart}[m
[31m-        onTouchMove={handleTouchMove}[m
[31m-        onTouchEnd={handleTouchEnd}[m
[31m-      >[m
[32m+[m[32m      <GestureDetector gesture={composedGesture}>[m
[32m+[m[32m        <View style={{ flex: 1 }}>[m
           <Animated.View [m
             style={{ [m
         position: 'absolute', [m
[36m@@ -1551,9 +1520,7 @@[m [mexport default function HomeScreen() {[m
           );[m
         }, [screenWidth, viewableHeight, nucleusX, nucleusY])}[m
         [m
[31m-          </Animated.View>  {/* ‚Üê Close transformed grid container */}[m
[31m-      [m
[31m-      {/* Central Raindrop Logo with Ripple - THE NUCLEUS (ORIGIN POINT 0,0) - ALWAYS VISIBLE, STAYS FIXED */}[m
[32m+[m[32m      {/* Central Raindrop Logo with Ripple - THE NUCLEUS (ORIGIN POINT 0,0) - ROTATES WITH GRID */}[m
       <View [m
         style={{ [m
           position: 'absolute',[m
[36m@@ -1616,7 +1583,7 @@[m [mexport default function HomeScreen() {[m
         </View>[m
       </View>[m
 [m
[31m-      {/* Pulsating Blips for Nearby Devices - Now inside gesture handlers for full-screen gesture detection */}[m
[32m+[m[32m      {/* Pulsating Blips for Nearby Devices - INSIDE TRANSFORMED CONTAINER, ROTATE WITH GRID */}[m
       <View [m
         style={{ [m
           position: 'absolute', [m
[36m@@ -1693,6 +1660,8 @@[m [mexport default function HomeScreen() {[m
           </View>[m
         )}[m
       </View>[m
[32m+[m[41m        [m
[32m+[m[32m          </Animated.View>  {/* ‚Üê Close transformed